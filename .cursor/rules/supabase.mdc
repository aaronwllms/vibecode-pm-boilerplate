---
description: Supabase integration patterns using @supabase/ssr
globs:
  - 'src/**/*.ts'
  - 'src/**/*.tsx'
  - 'src/utils/supabase.ts'
  - 'src/middleware.ts'
  - 'supabase/migrations/**/*.sql'
  - 'scripts/db-preflight.sh'
---

# Supabase Integration (@supabase/ssr)

## Migration Safety Protocol

### Before ANY Database Operation

**ALWAYS verify your environment to prevent accidental changes to the wrong database.**

1. **Check Project Linkage:**
```bash
pnpm db:status           # Shows current Supabase linkage
# OR
supabase status          # Direct CLI command
```

2. **Run Preflight Check:**
```bash
pnpm db:check            # Info only - shows what you're linked to
pnpm db:push:safe        # Safe push - requires confirmation
```

3. **Verify Intent:**
- Local development: Ensure local Supabase is running (`pnpm supabase:start`)
- Remote push: Confirm project ref matches your target environment

### Safe vs Dangerous Commands

**‚úÖ Safe Commands (Local Only):**
- `pnpm supabase:start` - Start local Supabase Docker containers
- `pnpm supabase:stop` - Stop local Supabase
- `pnpm db:reset` - Reset LOCAL database and apply all migrations
- `pnpm db:seed` - Seed LOCAL database with test data
- `pnpm db:types` - Generate TypeScript types from LOCAL database

**‚ö†Ô∏è Dangerous Commands (Affects Remote):**
- `pnpm db:push` - Pushes migrations to remote project
- `supabase db push` - Same as above
- `supabase link` - Changes which project you're linked to
- `supabase db remote commit` - Commits remote changes

**ALWAYS run `pnpm db:check` before dangerous commands!**

### Migration Creation Safety

**‚úÖ CORRECT: Use Supabase CLI**
```bash
# Let Supabase CLI generate the timestamp
supabase migration new add_user_preferences

# This creates: supabase/migrations/[TIMESTAMP]_add_user_preferences.sql
```

**‚ùå NEVER: Manually Create Migration Files**
Manual timestamps cause migration ordering issues, conflicts, and incorrect sequencing.

### Recommended Workflows

**Local Development (Safe):**
```bash
# 1. Start local Supabase
pnpm supabase:start

# 2. Create migration
supabase migration new my_feature

# 3. Edit the SQL file in supabase/migrations/

# 4. Apply locally and test
pnpm db:reset

# 5. Generate types
pnpm db:types

# 6. Test your app locally
pnpm dev
```

**Push to Remote (Requires Caution):**
```bash
# 1. Verify current linkage
pnpm db:check

# 2. Link to correct project (if needed)
supabase link --project-ref YOUR_PROJECT_REF

# 3. Push with safety check
pnpm db:push:safe

# 4. Generate types from remote
pnpm db:types
```

### Red Flags & Anti-Patterns

**üö® STOP if you see these:**
- Running `db:push` without knowing which project you're linked to
- Creating migration files with manual timestamps
- Pushing migrations that haven't been tested locally
- Not having a local Supabase instance for testing
- Skipping `db:reset` after creating migrations

**‚ö†Ô∏è Common Mistakes:**
- Assuming you're in local mode when linked to remote
- Forgetting to `supabase:start` before local development
- Not running `db:types` after schema changes
- Creating migrations with DROP/DELETE statements without backups

### Environment Verification Checklist

Before any database operation:
- [ ] I know which environment I'm targeting (local/staging/production)
- [ ] I've run `pnpm db:check` to verify linkage
- [ ] I've tested migrations locally with `db:reset`
- [ ] I've generated TypeScript types with `db:types`
- [ ] I understand if this command affects local or remote

**üí° Tip:** Use the db-migration Cursor command for guided workflows with built-in safety checks. (Type `@db-migration` in Cursor)

## Context-Specific Client Usage

### Client Components
```typescript
import { createClient } from '@/utils/supabase'

// Use in client components with 'use client' directive
const supabase = createClient()
```

### Server Components
```typescript
import { createServerClient } from '@/utils/supabase'

// Use in Server Components and Server Actions
const supabase = await createServerClient()
```

### API Route Handlers
```typescript
import { createRouteHandlerClient } from '@/utils/supabase'

// Use in route.ts files
const supabase = createRouteHandlerClient()
```

### Middleware
```typescript
import { createMiddlewareClient } from '@/utils/supabase'

// Use in middleware.ts
const supabase = createMiddlewareClient(req)
```

## Best Practices
- Always handle authentication errors gracefully
- Implement proper TypeScript types for database queries
- Use Supabase Row Level Security (RLS) policies for data protection
- Handle auth state changes reactively
- Reference existing patterns in `src/app/api/auth/callback/route.ts`

## Security

**See `.cursor/rules/security.mdc` for comprehensive security patterns including:**
- RLS policy implementation
- Auth checks and validation
- DTO patterns for data protection
- Never exposing service role keys to client

**Key points:**
- Never commit Supabase keys to version control
- Store credentials in `.env.local`
- Use environment variables: `NEXT_PUBLIC_SUPABASE_URL`, `NEXT_PUBLIC_SUPABASE_ANON_KEY`
- Implement RLS policies for all tables
- Validate user inputs before queries

## Performance & Optimization

### Query Optimization Principles
- **Indexing**: Create indexes on columns in WHERE, JOIN, ORDER BY clauses
- **Avoid N+1 Queries**: Use nested selects for relations (`.select('*, relation_table(*)')`)
- **Pagination**: Always use `.range()` or `.limit()` for large result sets
- **Select Specific Columns**: Avoid `select('*')` - specify only needed fields
- **Filter Early**: Apply filters before sorting/limiting

### Caching & Connection Management
- Leverage TanStack Query for client-side caching (already configured)
- Always cleanup real-time subscriptions in useEffect return function
- Connection pooling is handled automatically by Supabase
- Consider edge caching (Vercel) or Redis for session/rate-limiting data

### Load Testing & Monitoring
- Test migrations in staging before production
- Monitor slow queries in Supabase Dashboard
- Contact support 48h before anticipated traffic spikes

## Code Organization Patterns

### Repository Pattern (Recommended)
- Abstract database operations into service layer (`src/services/`)
- Keep database logic separate from UI components
- Create repository files per domain: `posts-repository.ts`, `users-repository.ts`, `auth-service.ts`
- Export functions that encapsulate Supabase queries
- Handle errors within repositories before returning to components

### Business Logic Placement
- ‚úÖ **Application Code**: Complex business rules, multi-step workflows, validation
- ‚úÖ **Database Policies (RLS)**: Simple row-level access control
- ‚ùå **Supabase Edge Functions**: Avoid over-reliance to prevent vendor lock-in
- Keep most logic in application code for testability and portability

## Anti-Patterns to Avoid

### ‚ùå Direct Database Access from UI Components
- Never call Supabase directly from UI components
- Use custom hooks (TanStack Query) or repository functions
- Keep data fetching logic testable and reusable

### ‚ùå Poor Query Performance
- Don't fetch all columns with `select('*')`
- Always add filters, limits, and pagination
- Avoid multiple sequential queries when joins are available

### ‚ùå Skipping Row Level Security (RLS)
- Always enable RLS on tables with user data
- Don't rely solely on application-level authorization
- Test RLS policies thoroughly before production
- Use `auth.uid()` in policies for user-scoped access

**See `.cursor/rules/security.mdc` for detailed RLS implementation patterns.**

### ‚ùå Business Logic in Database Functions
- Keep business logic in application code for testability
- Use Supabase Functions only for performance-critical operations
- Avoid vendor lock-in by minimizing edge function reliance

### ‚ùå Manual Migration Management
- Always use `supabase migration new` - never manually create timestamped files
- Test all migrations locally before remote push

## Testing Supabase Integrations

**See `.cursor/rules/testing.mdc` for comprehensive testing patterns.**

### Testing Strategy
- **Unit Tests**: Mock Supabase client at module boundary
- **Integration Tests**: Use local Supabase or test database for API routes
- **RLS Policy Tests**: Use local Supabase to validate row-level security
- **Auth Flow Tests**: Mock auth state for protected route testing

### When to Use Test Database vs Mocks
- **Mocks**: Fast unit tests, component tests, isolated logic
- **Local Supabase**: Integration tests, migration validation, RLS testing, E2E tests
- Mock Supabase client by returning objects with chainable methods that resolve to `{ data, error }`

## Production Operations

### Monitoring
- Monitor slow queries in Supabase Dashboard (Query Performance tab)
- Set up alerts for connection pool exhaustion
- Track API response times with Vercel Analytics
- Review and optimize query patterns regularly

### Backup & Recovery
- Supabase provides daily automatic backups
- Enable Point-in-Time Recovery (PITR) for production databases
- Test restore procedures in staging
- Document recovery runbook

### Capacity Planning
- Monitor database size and connection usage
- Plan upgrades proactively based on growth trends
- Contact Supabase support 48h before anticipated traffic spikes
