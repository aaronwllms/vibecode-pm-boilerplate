---
description: Comprehensive error handling, logging, and monitoring standards
autoAttach:
  globs:
    - "src/**/*.{ts,tsx}"
    - "src/app/api/**/*.ts"
    - "src/app/**/error.tsx"
---

# Error Handling & Logging Standards

## Philosophy
- **User-facing errors**: Clear, actionable, never expose internals
- **Developer errors**: Rich context, stack traces, debugging info
- **Security-first**: Never log sensitive data (passwords, tokens, PII)
- **Fail gracefully**: Always provide fallback UI and recovery paths

## Error Taxonomy

| Error Code | HTTP | Usage |
|------------|------|-------|
| `VALIDATION_ERROR` | 400 | Input validation failed |
| `INVALID_FORMAT` | 400 | Data format incorrect |
| `MISSING_REQUIRED_FIELD` | 400 | Required field not provided |
| `UNAUTHORIZED` | 401 | Not authenticated |
| `FORBIDDEN` | 403 | Lacks permission |
| `SESSION_EXPIRED` | 401 | Auth session expired |
| `NOT_FOUND` | 404 | Resource doesn't exist |
| `CONFLICT` | 409 | Resource already exists |
| `GONE` | 410 | Permanently deleted |
| `RATE_LIMITED` | 429 | Too many requests |
| `QUOTA_EXCEEDED` | 429 | API quota exceeded |
| `INTERNAL_ERROR` | 500 | Unexpected server error |
| `DATABASE_ERROR` | 500 | Database operation failed |
| `EXTERNAL_API_ERROR` | 502 | Third-party API failed |
| `TIMEOUT` | 504 | Operation timed out |
| `SUPABASE_AUTH_ERROR` | 401 | Supabase auth failure |
| `SUPABASE_RLS_ERROR` | 403 | Row Level Security rejection |
| `SUPABASE_CONNECTION_ERROR` | 500 | Cannot connect to Supabase |

## Response Envelopes

**Success:**
```typescript
NextResponse.json({ success: true, data: result }, { status: 200 })
```

**Error:**
```typescript
NextResponse.json(
  { success: false, error: { message: 'User-friendly error message', code: 'VALIDATION_ERROR' } },
  { status: 400 }
)
```

**Server Actions:** Same structure, return objects instead of NextResponse

## Logger Utility

```typescript
import { logger } from '@/utils/logger'

logger.error({
  source: 'api/posts/route.ts',
  message: 'Failed to fetch posts',
  code: 'DATABASE_ERROR',
  context: { userId: '123' },
  error // Optional: Error object for stack traces
})
```

**Log Levels:** `debug` (dev only), `info`, `warn`, `error`

**Required Parameters:**
- `source` - File path (e.g., 'api/posts/route.ts')
- `message` - Human-readable description
- `code` - Error code from taxonomy

## Error Handling Patterns

### API Routes
```typescript
import { NextRequest, NextResponse } from 'next/server'
import { logger } from '@/utils/logger'

export async function GET(request: NextRequest) {
  const source = 'api/posts/route.ts'
  
  try {
    const posts = await fetchPosts()
    return NextResponse.json({ success: true, data: posts })
  } catch (error) {
    logger.error({ source, message: 'Failed to fetch posts', code: 'INTERNAL_ERROR', error })
    return NextResponse.json(
      { success: false, error: { message: 'Failed to fetch posts', code: 'INTERNAL_ERROR' } },
      { status: 500 }
    )
  }
}
```

**Key principles:**
- Wrap all async operations in try/catch
- Log with source, message, code, and error object
- Return generic user-friendly messages (never expose stack traces)
- Use appropriate HTTP status codes

**Reference:** See `src/app/api/message/route.ts` for complete implementation

### Server Actions
Follow same pattern as API routes, return objects instead of NextResponse.

### Client Components (React Query)
```typescript
'use client'
import { useQuery } from '@tanstack/react-query'
import { logger } from '@/utils/logger'
import { ErrorDisplay } from '@/components/error-display'

export function PostList() {
  const { data, error, isLoading } = useQuery({
    queryKey: ['posts'],
    queryFn: async () => {
      const response = await fetch('/api/posts')
      if (!response.ok) throw new Error('Failed to fetch')
      return response.json()
    }
  })
  
  if (error) {
    logger.error({ source: 'components/post-list.tsx', message: error.message, code: 'EXTERNAL_API_ERROR', error })
    return <ErrorDisplay message="Failed to load posts" />
  }
  
  if (isLoading) return <div>Loading...</div>
  return <div>{/* Render posts */}</div>
}
```

### Error Boundaries
```typescript
import { ErrorBoundary } from '@/components/error-boundary'
import { ErrorFallback } from '@/components/error-fallback'

<ErrorBoundary fallback={<ErrorFallback />} source="app/posts/page.tsx">
  <PostList />
</ErrorBoundary>
```

## Supabase Error Handling

### Common Supabase Error Codes
- `PGRST116` → `NOT_FOUND` (row not found)
- `23505` → `CONFLICT` (unique constraint violation)
- `23503` → `VALIDATION_ERROR` (foreign key violation)
- `42501` → `FORBIDDEN` (RLS policy violation)

### Database Errors
```typescript
const { data, error } = await supabase.from('posts').select('*').eq('id', postId).single()

if (error) {
  const errorCode = error.code === 'PGRST116' ? 'NOT_FOUND' : 'DATABASE_ERROR'
  logger.error({ source: 'api/posts/[id]/route.ts', message: error.message, code: errorCode, context: { postId, supabaseCode: error.code } })
  const statusCode = errorCode === 'NOT_FOUND' ? 404 : 500
  return NextResponse.json(
    { success: false, error: { message: errorCode === 'NOT_FOUND' ? 'Post not found' : 'Database error', code: errorCode } },
    { status: statusCode }
  )
}
```

**Auth Errors:**
- Never leak user existence ("Invalid credentials" not "User doesn't exist")
- Log with context but generic user messages

**Reference:** See `.cursor/rules/security.mdc` for detailed auth patterns

## Security: What NOT to Log

**Never log:** Passwords, API keys, auth tokens, credit cards, SSNs, full request/response bodies

**Safe to log:** User IDs, email addresses (auth context only), request paths, error codes, non-sensitive metadata

Logger utility automatically sanitizes common sensitive field names.

## User-Facing Error Messages

**Good Examples:**
- "We couldn't find that post. It may have been deleted."
- "Your session expired. Please sign in again."
- "Something went wrong. Please try again, or contact support if this continues."

**Bad Examples:**
- "Error: ECONNREFUSED" (too technical)
- "An error occurred" (too vague)
- "Internal server error at line 42" (leaks internals)

**Guidelines:** Be clear, actionable, empathetic, honest, and concise (1-2 sentences max)

## Error UI Components

### ErrorDisplay
```typescript
import { ErrorDisplay } from '@/components/error-display'

<ErrorDisplay message="Failed to load posts" code="DATABASE_ERROR" variant="destructive" />
```

### ErrorFallback
```typescript
import { ErrorFallback } from '@/components/error-fallback'

<ErrorBoundary fallback={<ErrorFallback />}>
  <YourComponent />
</ErrorBoundary>
```

## Production Logging

**Log Levels:** info, warn, error enabled; debug disabled

**Vercel Integration:** All structured console output captured automatically. Logger formats as JSON for querying in Vercel Dashboard.

**Access logs:** Vercel Dashboard → Your Project → Logs

## Testing Error Scenarios

**See `.cursor/rules/testing.mdc` for comprehensive testing patterns.**

```typescript
it('should handle errors gracefully', async () => {
  vi.mocked(fetchPosts).mockRejectedValue(new Error('DB error'))
  const response = await GET(mockRequest)
  const data = await response.json()
  
  expect(response.status).toBe(500)
  expect(data.success).toBe(false)
  expect(data.error.code).toBe('INTERNAL_ERROR')
})
```

## Quick Checklist

Before shipping error handling code:
- [ ] All async operations wrapped in try/catch
- [ ] Errors logged with source and code
- [ ] User-friendly error messages (not internal details)
- [ ] Appropriate HTTP status codes
- [ ] No sensitive data in logs
- [ ] Error boundaries for critical UI sections
- [ ] Tests cover error scenarios
- [ ] Error codes use standard taxonomy
